- 一个原则:
    依赖倒置原则:要依赖抽象,不要依赖具体类.

    这个原则,听起来很像"针对接口编程,不要针对实现编程."
    然而,这里更强调**抽象**.
    即,不能让高层组件依赖底层组件.
    而且,不管高层组件(PizzaStore)或低层组件(Pizza),都应该依赖于抽象.
    所以FactoryMethod中,高层组件不应依赖具体类(具体Pizza类)

    - 实例:
        ![](E:\JavaProjects\DesignPatterns\src\main\java\FactoryPattern\FactoryPattern\FactoryPattern0.jpg)

        在此原则中,高层组件(PizzaStore)和底层组件(具体Pizza类)都依赖于抽象类Pizza.

        即:底层组件**倒置**依赖于高层的抽象.并且,高层和低层均依赖于同一个抽象.

    -   在设计中,通过以下几点避免违反依赖倒置原则:

        1.  变量不可以持有具体类的引用.

            用工厂来避免new

        2.  不要让类派生具体类.

            派生子具体类,你就会依赖具体类.

            请派生一个抽象(**接口或抽象类**)

        3.  不要覆盖基类中的方法.

            否则,你的基类就不是一个真正适合被继承的抽象.

         当然,任何Java程序都有可能违反以上这些注意事项!

        

        **但是**,

        >   当你将这些注意事项内化成你思考的一部分时,在以后的设计时,你将知道何时有足够的理由违反这些注意事项.比如初始化一个字符串,字符串不可改变,直接new就无伤大雅,你可以直接这么做.
        >
        >   
        >
        >   又比如:如果有类可以改变,你可以采用工厂模式来封装改变,

-   提出新的问题:

    -   假设在此问题中，同一种Pizza的加工方式一样【原题是原料组件一样】，(例如ChessPizza都需要cut、wrap、delivery。而PepperoniPizza都需要cut和wrap)，但是不同地区之间的cut、wrap、delivery的方法可能不同【原题是运用原料的方式可能不一样】。（例如NewYork的Store的cut方法是“Cut into secotrs”切成扇形，而Chicargo的Store的Cut方法是“Cut into pieces”切成条状）。
    -   如果用工厂方法模式，当地区很多并且Pizza种类很多时，同一种Pizza的相同或者不同方法都要在所有不同地区之间重写。
    -   为避免出现像工厂方法中的分别依赖两个抽象情况，需要用到依赖倒置原则。

-   关于代码：

    其核心要点是：

    通过抽象工厂所提供的接口，创建产品家族

    利用这个接口书写代码，将代码从实际工厂中解耦。

    以便在不同条件下（不同区域，不同实现方案）制造不同的产品。

-   抽象工厂模式

    -   定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定的具体类。
    -   几点说明：
        1.  其实抽象工厂经常以工厂方法的方式实现。抽象工厂的每个方法实际上看起来都像是工厂方法。（例如Fcut（）等）子类的方法覆盖这些abstract方法来实现自己的特色。
        2.  工厂方法用继承创建对象，抽象工厂则是组合
        3.  工厂方法之不过就是通过子类来创建对象，以此来让子类决定具体类型。即它仅负责将客户从具体类型中解耦。
        4.  抽象工厂提供一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。要想利用这个工厂，必须实例化它，然后将他传入一些针对抽象类型所写的代码中。所以他的另一个优点是可以把一群相关产品集合起来。
        5.  使用条件：
            1.  当需要创建产品家族和想让制造的产品集合起来时，用抽象工厂。
            2.  当需要把客户代码从实例化具体类中解耦，或者目前还不知道将来用哪些具体类时，用工厂方法。将工厂方法继承为子类，并实现具体方法即可。